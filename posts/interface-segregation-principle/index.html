<!doctype html><html lang="vi-VN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="SOLID - Interface Segregation Principle" /><meta property="og:locale" content="vi_VN" /><meta name="description" content="Đây là nguyên lý thứ 4 trong bộ 5 nguyên lí SOLID. Nguyên lý này chỉ ra rằng interface của 1 chương trình nên được phân tách nhỏ sao cho những người lập trình chỉ cần thực thi những interface mà họ cần. Tránh việc phải thực thi 1 interface quá lớn, bao gồm quá nhiều những phương thức thừa thãi. 1. Đặt vấn đề Giả sử chúng ta làm việc với đối tượng Document, xoay quanh đối tượng này, chúng ta có các thao tác liên quan như in ấn, scan, chuyển fax,… Để nhanh chóng, chúng ta định nghĩa hết tất cả đối tượng này vào trong 1 interface duy nhất. Tiếp đến, ta có đối tượng MultiFunctionPrinter thực thi interface này và định nghĩa toàn bộ các phương thức tương ứng. Đến đây, chương trình hoạt động hoàn toàn bình thường. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Document { } public interface IMachine { void Print(Document d); void Scan(Document d); void Fax(Document d); } public class MultiFunctionPrinter : IMachine { public void Print(Document d) { // } public void Scan(Document d) { // } public void Fax(Document d) { // } } 2. Vi phạm nguyên lí Sau đó, chúng ta mở rộng hệ thống, hỗ trợ các thao tác quản lý tài liệu thông qua 1 máy in cũ hơn, đặt tên OldFashionPrinter, chiếc máy này chỉ có duy nhất 1 chức năng Print, không thể Scan hay Fax. Lúc này, để đảm bảo hệ thống hoạt động được, ta phải thực thi interface IMachine cho lớp này. Tuy nhiên, ta phải viết hướng dẫn rõ ràng bởi vì lớp này không thể Scan hay Fax. Điều này gây nhầm lẫn rất lớn, bởi vì class IMachine thực thi interface IMachine nhưng nó không thể thực hiện hết chức năng của interface này. Điều này đã vi phạm nguyên lí Interface Segregation, nguyên lí này đảm bảo rằng: People don’t pay for thing they don’t need Tức là, chúng ta không cần phải thực hiện những tính năng mà chúng ta không cần đến. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class OldFashionPrinter : IMachine { public void Print(Document d) { // } public void Scan(Document d) { throw new NotImplementedException(); } public void Fax(Document d) { throw new NotImplementedException(); } } 3. Cách giải quyết Cách thức giải quyết khá đơn giản, thay vì khai báo 1 interface chịu trách nhiệm cho rất nhiều công việc cùng lúc. Chúng ta nên chia nhỏ interface này, mỗi interface nhỏ chịu trách nhiệm cho 1 công việc cụ thể. (Seperation of Concern) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public interface IPrinter { void Print(Document d); } public interface IScanner { void Scan(Document d); } public interface IFaxer { void Fax(Document d); } Lúc này, giả sử 1 đối tượng Photocopier có khả năng Print và Scan, chúng ta chỉ cần thực hiện như dưới đây: 1 2 3 4 5 6 7 8 9 10 11 12 public class Photocopier : IPrinter, IScanner { void Print(Document d) { } void Scan(Document d) { } } Hoặc nếu muốn 1 interface mang tính trừu tượng hơn, ta hoàn toàn có thể kết hợp các interface nhỏ thành 1 interface lớn hơn thông qua tính kế thừa của interface. 1 2 3 4 public interface IMultiFunctionDevice : IScanner, IPrinter, IFaxer { } Lúc này, ta có thể định nghĩa lớp MultiFunctionMachine thực thi interface IMultiFunctionDevice và định nghĩa tất cả các phương thức: 1 2 3 4 5 6 public class MultiFunctionMachine : IMultiFunctionDevice { public void Print(Document d) {} public void Scan(Document d) {} public void Fax(Document d) {} } Hoặc, nếu đã có các lớp thực thi những interface con, ta có thể dùng luôn các lớp con này. Cách thức thực hiện dưới đây còn được biết đến với tên gọi decorator pattern. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class MultiFunctionMachineComposition : IMultiFunctionDevice { private IPrinter printer; private IScanner scanner; private IFaxer faxer; public MultiFunctionMachineComposition(IPrinter printer, IScanner scanner, IFaxer faxer) { this.printer = printer; this.scanner = scanner; this.faxer = faxer; } public void Print(Document d) { printer.Print(d); } public void Scan(Document d) { scanner.Scan(d); } public void Fax(Document d) { faxer.Fax(d); } } Tham khảo Design Patterns in C# and .NET" /><meta property="og:description" content="Đây là nguyên lý thứ 4 trong bộ 5 nguyên lí SOLID. Nguyên lý này chỉ ra rằng interface của 1 chương trình nên được phân tách nhỏ sao cho những người lập trình chỉ cần thực thi những interface mà họ cần. Tránh việc phải thực thi 1 interface quá lớn, bao gồm quá nhiều những phương thức thừa thãi. 1. Đặt vấn đề Giả sử chúng ta làm việc với đối tượng Document, xoay quanh đối tượng này, chúng ta có các thao tác liên quan như in ấn, scan, chuyển fax,… Để nhanh chóng, chúng ta định nghĩa hết tất cả đối tượng này vào trong 1 interface duy nhất. Tiếp đến, ta có đối tượng MultiFunctionPrinter thực thi interface này và định nghĩa toàn bộ các phương thức tương ứng. Đến đây, chương trình hoạt động hoàn toàn bình thường. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Document { } public interface IMachine { void Print(Document d); void Scan(Document d); void Fax(Document d); } public class MultiFunctionPrinter : IMachine { public void Print(Document d) { // } public void Scan(Document d) { // } public void Fax(Document d) { // } } 2. Vi phạm nguyên lí Sau đó, chúng ta mở rộng hệ thống, hỗ trợ các thao tác quản lý tài liệu thông qua 1 máy in cũ hơn, đặt tên OldFashionPrinter, chiếc máy này chỉ có duy nhất 1 chức năng Print, không thể Scan hay Fax. Lúc này, để đảm bảo hệ thống hoạt động được, ta phải thực thi interface IMachine cho lớp này. Tuy nhiên, ta phải viết hướng dẫn rõ ràng bởi vì lớp này không thể Scan hay Fax. Điều này gây nhầm lẫn rất lớn, bởi vì class IMachine thực thi interface IMachine nhưng nó không thể thực hiện hết chức năng của interface này. Điều này đã vi phạm nguyên lí Interface Segregation, nguyên lí này đảm bảo rằng: People don’t pay for thing they don’t need Tức là, chúng ta không cần phải thực hiện những tính năng mà chúng ta không cần đến. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class OldFashionPrinter : IMachine { public void Print(Document d) { // } public void Scan(Document d) { throw new NotImplementedException(); } public void Fax(Document d) { throw new NotImplementedException(); } } 3. Cách giải quyết Cách thức giải quyết khá đơn giản, thay vì khai báo 1 interface chịu trách nhiệm cho rất nhiều công việc cùng lúc. Chúng ta nên chia nhỏ interface này, mỗi interface nhỏ chịu trách nhiệm cho 1 công việc cụ thể. (Seperation of Concern) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public interface IPrinter { void Print(Document d); } public interface IScanner { void Scan(Document d); } public interface IFaxer { void Fax(Document d); } Lúc này, giả sử 1 đối tượng Photocopier có khả năng Print và Scan, chúng ta chỉ cần thực hiện như dưới đây: 1 2 3 4 5 6 7 8 9 10 11 12 public class Photocopier : IPrinter, IScanner { void Print(Document d) { } void Scan(Document d) { } } Hoặc nếu muốn 1 interface mang tính trừu tượng hơn, ta hoàn toàn có thể kết hợp các interface nhỏ thành 1 interface lớn hơn thông qua tính kế thừa của interface. 1 2 3 4 public interface IMultiFunctionDevice : IScanner, IPrinter, IFaxer { } Lúc này, ta có thể định nghĩa lớp MultiFunctionMachine thực thi interface IMultiFunctionDevice và định nghĩa tất cả các phương thức: 1 2 3 4 5 6 public class MultiFunctionMachine : IMultiFunctionDevice { public void Print(Document d) {} public void Scan(Document d) {} public void Fax(Document d) {} } Hoặc, nếu đã có các lớp thực thi những interface con, ta có thể dùng luôn các lớp con này. Cách thức thực hiện dưới đây còn được biết đến với tên gọi decorator pattern. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class MultiFunctionMachineComposition : IMultiFunctionDevice { private IPrinter printer; private IScanner scanner; private IFaxer faxer; public MultiFunctionMachineComposition(IPrinter printer, IScanner scanner, IFaxer faxer) { this.printer = printer; this.scanner = scanner; this.faxer = faxer; } public void Print(Document d) { printer.Print(d); } public void Scan(Document d) { scanner.Scan(d); } public void Fax(Document d) { faxer.Fax(d); } } Tham khảo Design Patterns in C# and .NET" /><link rel="canonical" href="https://dalatcoder.github.io/posts/interface-segregation-principle/" /><meta property="og:url" content="https://dalatcoder.github.io/posts/interface-segregation-principle/" /><meta property="og:site_name" content="DalatCoder Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-09-03T16:58:00+07:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="SOLID - Interface Segregation Principle" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-09-03T16:58:00+07:00","datePublished":"2022-09-03T16:58:00+07:00","description":"Đây là nguyên lý thứ 4 trong bộ 5 nguyên lí SOLID. Nguyên lý này chỉ ra rằng interface của 1 chương trình nên được phân tách nhỏ sao cho những người lập trình chỉ cần thực thi những interface mà họ cần. Tránh việc phải thực thi 1 interface quá lớn, bao gồm quá nhiều những phương thức thừa thãi. 1. Đặt vấn đề Giả sử chúng ta làm việc với đối tượng Document, xoay quanh đối tượng này, chúng ta có các thao tác liên quan như in ấn, scan, chuyển fax,… Để nhanh chóng, chúng ta định nghĩa hết tất cả đối tượng này vào trong 1 interface duy nhất. Tiếp đến, ta có đối tượng MultiFunctionPrinter thực thi interface này và định nghĩa toàn bộ các phương thức tương ứng. Đến đây, chương trình hoạt động hoàn toàn bình thường. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Document { } public interface IMachine { void Print(Document d); void Scan(Document d); void Fax(Document d); } public class MultiFunctionPrinter : IMachine { public void Print(Document d) { // } public void Scan(Document d) { // } public void Fax(Document d) { // } } 2. Vi phạm nguyên lí Sau đó, chúng ta mở rộng hệ thống, hỗ trợ các thao tác quản lý tài liệu thông qua 1 máy in cũ hơn, đặt tên OldFashionPrinter, chiếc máy này chỉ có duy nhất 1 chức năng Print, không thể Scan hay Fax. Lúc này, để đảm bảo hệ thống hoạt động được, ta phải thực thi interface IMachine cho lớp này. Tuy nhiên, ta phải viết hướng dẫn rõ ràng bởi vì lớp này không thể Scan hay Fax. Điều này gây nhầm lẫn rất lớn, bởi vì class IMachine thực thi interface IMachine nhưng nó không thể thực hiện hết chức năng của interface này. Điều này đã vi phạm nguyên lí Interface Segregation, nguyên lí này đảm bảo rằng: People don’t pay for thing they don’t need Tức là, chúng ta không cần phải thực hiện những tính năng mà chúng ta không cần đến. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class OldFashionPrinter : IMachine { public void Print(Document d) { // } public void Scan(Document d) { throw new NotImplementedException(); } public void Fax(Document d) { throw new NotImplementedException(); } } 3. Cách giải quyết Cách thức giải quyết khá đơn giản, thay vì khai báo 1 interface chịu trách nhiệm cho rất nhiều công việc cùng lúc. Chúng ta nên chia nhỏ interface này, mỗi interface nhỏ chịu trách nhiệm cho 1 công việc cụ thể. (Seperation of Concern) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public interface IPrinter { void Print(Document d); } public interface IScanner { void Scan(Document d); } public interface IFaxer { void Fax(Document d); } Lúc này, giả sử 1 đối tượng Photocopier có khả năng Print và Scan, chúng ta chỉ cần thực hiện như dưới đây: 1 2 3 4 5 6 7 8 9 10 11 12 public class Photocopier : IPrinter, IScanner { void Print(Document d) { } void Scan(Document d) { } } Hoặc nếu muốn 1 interface mang tính trừu tượng hơn, ta hoàn toàn có thể kết hợp các interface nhỏ thành 1 interface lớn hơn thông qua tính kế thừa của interface. 1 2 3 4 public interface IMultiFunctionDevice : IScanner, IPrinter, IFaxer { } Lúc này, ta có thể định nghĩa lớp MultiFunctionMachine thực thi interface IMultiFunctionDevice và định nghĩa tất cả các phương thức: 1 2 3 4 5 6 public class MultiFunctionMachine : IMultiFunctionDevice { public void Print(Document d) {} public void Scan(Document d) {} public void Fax(Document d) {} } Hoặc, nếu đã có các lớp thực thi những interface con, ta có thể dùng luôn các lớp con này. Cách thức thực hiện dưới đây còn được biết đến với tên gọi decorator pattern. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class MultiFunctionMachineComposition : IMultiFunctionDevice { private IPrinter printer; private IScanner scanner; private IFaxer faxer; public MultiFunctionMachineComposition(IPrinter printer, IScanner scanner, IFaxer faxer) { this.printer = printer; this.scanner = scanner; this.faxer = faxer; } public void Print(Document d) { printer.Print(d); } public void Scan(Document d) { scanner.Scan(d); } public void Fax(Document d) { faxer.Fax(d); } } Tham khảo Design Patterns in C# and .NET","headline":"SOLID - Interface Segregation Principle","mainEntityOfPage":{"@type":"WebPage","@id":"https://dalatcoder.github.io/posts/interface-segregation-principle/"},"url":"https://dalatcoder.github.io/posts/interface-segregation-principle/"}</script><title>SOLID - Interface Segregation Principle | DalatCoder Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="DalatCoder Blog"><meta name="application-name" content="DalatCoder Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.21.3/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"> <img src="https://avatars.githubusercontent.com/u/49048131?s=400&u=f3a43cb86922fdb1e9144d5e76e8937b5b557119&v=4" width="112" height="112" alt="avatar" onerror="this.style.display='none'"> </a><h1 class="site-title"> <a href="/">DalatCoder Blog</a></h1><p class="site-subtitle fst-italic mb-0">My Notes About Programming</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>TRANG CHỦ</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CÁC DANH MỤC</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag"></i> <span>CÁC THẺ</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>LƯU TRỮ</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>GIỚI THIỆU</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/dalatcoder" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['hieunguyentrong.dev','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/"> Trang chủ </a> </span> <span>SOLID - Interface Segregation Principle</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Bài viết</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Tìm kiếm..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Hủy</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>SOLID - Interface Segregation Principle</h1><div class="post-meta text-muted"> <span> Đăng lúc <time data-ts="1662199080" data-df="DD/MM/YYYY" data-bs-toggle="tooltip" data-bs-placement="bottom" > 03/09/2022 </time> </span><div class="d-flex justify-content-between"> <span> Viết bởi <em> <a href="https://github.com/dalatcoder">Hieu Nguyen Trong</a> </em> </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="782 từ" > <em>4 phút</em> đọc</span></div></div></header><div class="content"><p>Đây là nguyên lý thứ 4 trong bộ 5 nguyên lí SOLID. Nguyên lý này chỉ ra rằng <code class="language-plaintext highlighter-rouge">interface</code> của 1 chương trình nên được phân tách nhỏ sao cho những người lập trình chỉ cần thực thi những <code class="language-plaintext highlighter-rouge">interface</code> mà họ cần. Tránh việc phải thực thi 1 <code class="language-plaintext highlighter-rouge">interface</code> quá lớn, bao gồm quá nhiều những phương thức thừa thãi.</p><h2 id="1-đặt-vấn-đề"><span class="me-2">1. Đặt vấn đề</span><a href="#1-đặt-vấn-đề" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Giả sử chúng ta làm việc với đối tượng <code class="language-plaintext highlighter-rouge">Document</code>, xoay quanh đối tượng này, chúng ta có các thao tác liên quan như in ấn, scan, chuyển fax,… Để nhanh chóng, chúng ta định nghĩa hết tất cả đối tượng này vào trong 1 <code class="language-plaintext highlighter-rouge">interface</code> duy nhất.</p><p>Tiếp đến, ta có đối tượng <code class="language-plaintext highlighter-rouge">MultiFunctionPrinter</code> thực thi <code class="language-plaintext highlighter-rouge">interface</code> này và định nghĩa toàn bộ các phương thức tương ứng. Đến đây, chương trình hoạt động hoàn toàn bình thường.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Đã sao chép!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">class</span> <span class="nc">Document</span>
<span class="p">{</span>

<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="nc">IMachine</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">Print</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">);</span>
  <span class="k">void</span> <span class="nf">Scan</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">);</span>
  <span class="k">void</span> <span class="nf">Fax</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">MultiFunctionPrinter</span> <span class="p">:</span> <span class="n">IMachine</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">Print</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">//</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Scan</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">//</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Fax</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">//</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="2-vi-phạm-nguyên-lí"><span class="me-2">2. Vi phạm nguyên lí</span><a href="#2-vi-phạm-nguyên-lí" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Sau đó, chúng ta mở rộng hệ thống, hỗ trợ các thao tác quản lý tài liệu thông qua 1 máy in cũ hơn, đặt tên <code class="language-plaintext highlighter-rouge">OldFashionPrinter</code>, chiếc máy này chỉ có duy nhất 1 chức năng <code class="language-plaintext highlighter-rouge">Print</code>, không thể <code class="language-plaintext highlighter-rouge">Scan</code> hay <code class="language-plaintext highlighter-rouge">Fax</code>.</p><p>Lúc này, để đảm bảo hệ thống hoạt động được, ta phải thực thi <code class="language-plaintext highlighter-rouge">interface</code> <code class="language-plaintext highlighter-rouge">IMachine</code> cho lớp này. Tuy nhiên, ta phải viết hướng dẫn rõ ràng bởi vì lớp này không thể <code class="language-plaintext highlighter-rouge">Scan</code> hay <code class="language-plaintext highlighter-rouge">Fax</code>. Điều này gây nhầm lẫn rất lớn, bởi vì <code class="language-plaintext highlighter-rouge">class</code> <code class="language-plaintext highlighter-rouge">IMachine</code> thực thi <code class="language-plaintext highlighter-rouge">interface</code> <code class="language-plaintext highlighter-rouge">IMachine</code> nhưng nó không thể thực hiện hết chức năng của <code class="language-plaintext highlighter-rouge">interface</code> này.</p><p>Điều này đã vi phạm nguyên lí <code class="language-plaintext highlighter-rouge">Interface Segregation</code>, nguyên lí này đảm bảo rằng:</p><blockquote><p>People don’t pay for thing they don’t need</p></blockquote><p>Tức là, chúng ta không cần phải thực hiện những tính năng mà chúng ta không cần đến.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Đã sao chép!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">class</span> <span class="nc">OldFashionPrinter</span> <span class="p">:</span> <span class="n">IMachine</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">Print</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">//</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Scan</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotImplementedException</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Fax</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotImplementedException</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="3-cách-giải-quyết"><span class="me-2">3. Cách giải quyết</span><a href="#3-cách-giải-quyết" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Cách thức giải quyết khá đơn giản, thay vì khai báo 1 <code class="language-plaintext highlighter-rouge">interface</code> chịu trách nhiệm cho rất nhiều công việc cùng lúc. Chúng ta nên chia nhỏ <code class="language-plaintext highlighter-rouge">interface</code> này, mỗi <code class="language-plaintext highlighter-rouge">interface</code> nhỏ chịu trách nhiệm cho 1 công việc cụ thể. (<code class="language-plaintext highlighter-rouge">Seperation of Concern</code>)</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Đã sao chép!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">interface</span> <span class="nc">IPrinter</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">Print</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="nc">IScanner</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">Scan</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="nc">IFaxer</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">Fax</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Lúc này, giả sử 1 đối tượng <code class="language-plaintext highlighter-rouge">Photocopier</code> có khả năng <code class="language-plaintext highlighter-rouge">Print</code> và <code class="language-plaintext highlighter-rouge">Scan</code>, chúng ta chỉ cần thực hiện như dưới đây:</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Đã sao chép!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">class</span> <span class="nc">Photocopier</span> <span class="p">:</span> <span class="n">IPrinter</span><span class="p">,</span> <span class="n">IScanner</span>
<span class="p">{</span>
  <span class="k">void</span> <span class="nf">Print</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">)</span>
  <span class="p">{</span>

  <span class="p">}</span>

  <span class="k">void</span> <span class="nf">Scan</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">)</span>
  <span class="p">{</span>

  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Hoặc nếu muốn 1 <code class="language-plaintext highlighter-rouge">interface</code> mang tính trừu tượng hơn, ta hoàn toàn có thể kết hợp các <code class="language-plaintext highlighter-rouge">interface</code> nhỏ thành 1 <code class="language-plaintext highlighter-rouge">interface</code> lớn hơn thông qua tính kế thừa của <code class="language-plaintext highlighter-rouge">interface</code>.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Đã sao chép!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">interface</span> <span class="nc">IMultiFunctionDevice</span> <span class="p">:</span> <span class="n">IScanner</span><span class="p">,</span> <span class="n">IPrinter</span><span class="p">,</span> <span class="n">IFaxer</span>
<span class="p">{</span>

<span class="p">}</span>
</pre></table></code></div></div><p>Lúc này, ta có thể định nghĩa lớp <code class="language-plaintext highlighter-rouge">MultiFunctionMachine</code> thực thi <code class="language-plaintext highlighter-rouge">interface</code> <code class="language-plaintext highlighter-rouge">IMultiFunctionDevice</code> và định nghĩa tất cả các phương thức:</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Đã sao chép!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">class</span> <span class="nc">MultiFunctionMachine</span> <span class="p">:</span> <span class="n">IMultiFunctionDevice</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">Print</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">Scan</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">Fax</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Hoặc, nếu đã có các lớp thực thi những <code class="language-plaintext highlighter-rouge">interface</code> con, ta có thể dùng luôn các lớp con này. Cách thức thực hiện dưới đây còn được biết đến với tên gọi <code class="language-plaintext highlighter-rouge">decorator pattern</code>.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Đã sao chép!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">class</span> <span class="nc">MultiFunctionMachineComposition</span> <span class="p">:</span> <span class="n">IMultiFunctionDevice</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="n">IPrinter</span> <span class="n">printer</span><span class="p">;</span>
  <span class="k">private</span> <span class="n">IScanner</span> <span class="n">scanner</span><span class="p">;</span>
  <span class="k">private</span> <span class="n">IFaxer</span> <span class="n">faxer</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">MultiFunctionMachineComposition</span><span class="p">(</span><span class="n">IPrinter</span> <span class="n">printer</span><span class="p">,</span> <span class="n">IScanner</span> <span class="n">scanner</span><span class="p">,</span> <span class="n">IFaxer</span> <span class="n">faxer</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">printer</span> <span class="p">=</span> <span class="n">printer</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="n">scanner</span> <span class="p">=</span> <span class="n">scanner</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="n">faxer</span> <span class="p">=</span> <span class="n">faxer</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Print</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printer</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Scan</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">scanner</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Fax</span><span class="p">(</span><span class="n">Document</span> <span class="n">d</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">faxer</span><span class="p">.</span><span class="nf">Fax</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="tham-khảo"><span class="me-2">Tham khảo</span><a href="#tham-khảo" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><a href="https://www.udemy.com/course/design-patterns-csharp-dotnet/">Design Patterns in C# and .NET</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/design-pattern/">Design Pattern</a>, <a href="/categories/solid/">SOLID</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/solid/" class="post-tag no-text-decoration" >solid</a> <a href="/tags/interface-segregation-principle/" class="post-tag no-text-decoration" >interface segregation principle</a> <a href="/tags/udemy/" class="post-tag no-text-decoration" >udemy</a> <a href="/tags/design-patterns-in-c-and-net/" class="post-tag no-text-decoration" >design patterns in c# and .net</a> <a href="/tags/decorator/" class="post-tag no-text-decoration" >decorator</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> Bài viết này được cấp phép bởi tác giả theo giấy phép <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> .</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Chia sẻ</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=SOLID%20-%20Interface%20Segregation%20Principle%20-%20DalatCoder%20Blog&url=https%3A%2F%2Fdalatcoder.github.io%2Fposts%2Finterface-segregation-principle%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=SOLID%20-%20Interface%20Segregation%20Principle%20-%20DalatCoder%20Blog&u=https%3A%2F%2Fdalatcoder.github.io%2Fposts%2Finterface-segregation-principle%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fdalatcoder.github.io%2Fposts%2Finterface-segregation-principle%2F&text=SOLID%20-%20Interface%20Segregation%20Principle%20-%20DalatCoder%20Blog" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Sao chép đường dẫn" data-title-succeed="Đã sao chép đường dẫn thành công!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Mới cập nhật</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/dependency-inversion-principle/">SOLID - Dependency Inversion Principle</a><li class="text-truncate lh-lg"> <a href="/posts/liskov-substitution-principle/">SOLID - Liskov Substitution Principle</a><li class="text-truncate lh-lg"> <a href="/posts/hello-dalatcoder/">Xin chào DalatCoder</a></ul></section><section><h2 class="panel-heading">Các thẻ thịnh hành</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/design-patterns-in-c-and-net/">design patterns in c# and .net</a> <a class="post-tag btn btn-outline-primary" href="/tags/solid/">solid</a> <a class="post-tag btn btn-outline-primary" href="/tags/udemy/">udemy</a> <a class="post-tag btn btn-outline-primary" href="/tags/jekyll/">jekyll</a> <a class="post-tag btn btn-outline-primary" href="/tags/newbie/">newbie</a> <a class="post-tag btn btn-outline-primary" href="/tags/dalatcoder/">dalatcoder</a> <a class="post-tag btn btn-outline-primary" href="/tags/decorator/">decorator</a> <a class="post-tag btn btn-outline-primary" href="/tags/demo/">demo</a> <a class="post-tag btn btn-outline-primary" href="/tags/dependency-inversion-principle/">dependency inversion principle</a> <a class="post-tag btn btn-outline-primary" href="/tags/design-pattern-overview/">design pattern overview</a></div></section></div><section id="toc-wrapper" class="ps-0 pe-4"><h2 class="panel-heading ps-3 pt-2 mb-2">Mục lục</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Bài viết liên quan</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/solid-single-responsibility-principle/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1662173400" data-df="DD/MM/YYYY" > 03/09/2022 </time><h4 class="pt-0 my-2">SOLID - Single Responsibility Principle</h4><div class="text-muted"><p> Single Responsibility hay còn gọi là nguyên lý đơn trách nhiệm. Đây là lời khuyên đầu tiên trong bộ 5 nguyên lý SOLID. Ý tưởng đằng sau nguyên lý này đó là: mỗi class, module hoặc function trong 1 ...</p></div></div></a></article><article class="col"> <a href="/posts/solid-open-close-principle/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1662176160" data-df="DD/MM/YYYY" > 03/09/2022 </time><h4 class="pt-0 my-2">SOLID - Open Close Principle</h4><div class="text-muted"><p> Đây là nguyên lí thứ 2 trong bộ 5 nguyên lý SOLID. Ý tưởng của nguyên lý này chỉ rằng: 1 đối tượng của phần mềm nên được mở rộng để thêm mới nhưng đóng lại khi thay đổi. Tức là, những thứ như class...</p></div></div></a></article><article class="col"> <a href="/posts/liskov-substitution-principle/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1662195660" data-df="DD/MM/YYYY" > 03/09/2022 </time><h4 class="pt-0 my-2">SOLID - Liskov Substitution Principle</h4><div class="text-muted"><p> Đây là nguyên lí thứ 3 trong bộ 5 nguyên lí SOLID. Theo như “Barbara Liskov” và “Jeannette Wing”, nguyên lí này chỉ ra rằng: Let Φ(x) be a property provable about objects x of type T. Then Φ(y)...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/liskov-substitution-principle/" class="btn btn-outline-primary" aria-label="Cũ hơn" ><p>SOLID - Liskov Substitution Principle</p></a> <a href="/posts/dependency-inversion-principle/" class="btn btn-outline-primary" aria-label="Mới hơn" ><p>SOLID - Dependency Inversion Principle</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p> © <time>2024</time> <a href="https://github.com/dalatcoder">Hieu Nguyen Trong</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Trừ khi có ghi chú khác, các bài viết đăng trên trang này được cấp phép bởi tác giả theo giấy phép Creative Commons Attribution 4.0 International (CC BY 4.0)." >Một số quyền được bảo lưu.</span></p><p>Trang web này được tạo bởi <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> với chủ đề <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Các thẻ thịnh hành</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/design-patterns-in-c-and-net/">design patterns in c# and .net</a> <a class="post-tag btn btn-outline-primary" href="/tags/solid/">solid</a> <a class="post-tag btn btn-outline-primary" href="/tags/udemy/">udemy</a> <a class="post-tag btn btn-outline-primary" href="/tags/jekyll/">jekyll</a> <a class="post-tag btn btn-outline-primary" href="/tags/newbie/">newbie</a> <a class="post-tag btn btn-outline-primary" href="/tags/dalatcoder/">dalatcoder</a> <a class="post-tag btn btn-outline-primary" href="/tags/decorator/">decorator</a> <a class="post-tag btn btn-outline-primary" href="/tags/demo/">demo</a> <a class="post-tag btn btn-outline-primary" href="/tags/dependency-inversion-principle/">dependency inversion principle</a> <a class="post-tag btn btn-outline-primary" href="/tags/design-pattern-overview/">design pattern overview</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">Đã có phiên bản mới của nội dung.</p><button type="button" class="btn btn-primary" aria-label="Update"> Cập nhật </button></div></aside><script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/vi.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.21.3/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script> /* Note: dependent library will be loaded in `js-selector.html` */ SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5"></p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
