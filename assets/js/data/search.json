[ { "title": "Back to Jekyll", "url": "/posts/back-to-jekyll/", "categories": "Newbie, Jekyll", "tags": "newbie, jekyll", "date": "2024-01-03 11:21:00 +0700", "snippet": "Quay lại với Jekyll để tạo nhanh trang blog cá nhân.1. Jekyll và ChirpyTài liệu về chirpy", "content": "Quay lại với Jekyll để tạo nhanh trang blog cá nhân.1. Jekyll và ChirpyTài liệu về chirpy" }, { "title": "Bắt đầu với Jekyll", "url": "/posts/get-started-with-jekyll/", "categories": "Newbie, Jekyll", "tags": "newbie, jekyll", "date": "2023-01-07 17:02:00 +0700", "snippet": "Làm quen với Jekyll để tạo nhanh trang blog cá nhân.1. Jekyll và ChirpyTài liệu về chirpy2. Cài đặtGetting Started3. Tạo post mớiWriting a new postĐể tạo nhanh 1 bài viết mới, có thể sử dụng công c...", "content": "Làm quen với Jekyll để tạo nhanh trang blog cá nhân.1. Jekyll và ChirpyTài liệu về chirpy2. Cài đặtGetting Started3. Tạo post mớiWriting a new postĐể tạo nhanh 1 bài viết mới, có thể sử dụng công cụ Jekyll Compose Chạy lệnh: bundle exec jekyll compose \"[post-name]\", ví dụ: bundle exec jekyll compose \"get-started-with-jekyll\" Chỉnh sửa post metadata, trong đó: title: Tiêu đề bài viết date: Ngày tạo bài viết categories: Phân loại bài viết. Ở ví dụ dưới đây, bài viết này thuộc phân loại con Jekyll trong phân loại Newbie tags: Đánh dấu các thẻ liên quan ---layout: posttitle: Bắt đầu với Jekylldate: 2023-01-07 17:02 +0700categories: [Newbie, Jekyll]tags: [newbie, jekyll]--- Tạo nội dung tóm tắt cho bài viết: phần nội dung tóm tắt được viết phía dưới phần metadata và được ngăn cách vớiphần nội dung chính bởi &lt;!-- more --&gt;---layout: posttitle: Bắt đầu với Jekylldate: 2023-01-07 17:02 +0700categories: [Newbie, Jekyll]tags: [newbie, jekyll]---Làm quen với Jekyll để tạo nhanh trang blog cá nhân.&lt;!-- more --&gt; Hoàn thiện phần nội dung còn lại của bài viết4. Chạy local serverĐể xem bài viết nháp, có thể khởi chạy local server thông qua lệnh: bundle exec jekyll s. Sau đó, truy cập vào đường dẫn http://localhost:4000/ để xem danh sách các bài viết.5. Xuất bảnXuất bản thông qua Github Action, chỉ cần commit và push lên Github." }, { "title": "SOLID - Dependency Inversion Principle", "url": "/posts/dependency-inversion-principle/", "categories": "Design Pattern, SOLID", "tags": "solid, dependency inversion principle, udemy, design patterns in c# and .net", "date": "2022-09-03 18:08:00 +0700", "snippet": "Đây là nguyên lý cuối cùng trong bộ 5 nguyên lý SOLID. Nguyên lý này khuyên rằng:các thành phần cấp cao của hệ thống không nên phụ thuộc trực tiếp vào các thànhphần cấp thấp hơn. Thay vào đó, cả 2 ...", "content": "Đây là nguyên lý cuối cùng trong bộ 5 nguyên lý SOLID. Nguyên lý này khuyên rằng:các thành phần cấp cao của hệ thống không nên phụ thuộc trực tiếp vào các thànhphần cấp thấp hơn. Thay vào đó, cả 2 nên cùng phụ thuộc vào các thành phần trừutượng (interface, abstract class,…).Thêm vào đó, các thành phần trừu tượng không nên phụ thuộc vào các lớp thực thi ( concrete implementations).Thay vào đó, các lớp thực thi phải phụ thuộc vào các thành phần trừu tượng (abstraction).1. Đặt vấn đềpublic enum Relationship{ Parent, Child, Sibling}public class Person{ public string Name;}public class Research{ // high-level module depends on low-level module public Research(Relationships relationships) { } static void Main(string[] args) { var parent = new Person { Name = \"John\" }; var child1 = new Person { Name = \"Chris\" }; var child2 = new Person { Name = \"Mary\" }; var relationships = new Relationships(); relationships.AddParentAndChild(parent, child1); relationships.AddParentAndChild(parent, child2); new Research(relationships); }}Tạo low-level module đặt tên Relationships, module này minh hoạ việc lưu giữ mốiquan hệ giữa những đối tượng Person.// low-level partpublic class Relationships{ private List&lt;(Person, Relationship, Person)&gt; relations = new List&lt;(Person, Relationship, Person)&gt;(); public void AddParentAndChild(Person parent, Person child) { relations.Add((parent, Relationship.Parent, child)); relations.Add((child, Relationship.Child, parent)); } public List&lt;(Person, Relationship, Person)&gt; Relations =&gt; relations;}Tiếp đến, để tiến hành xử lý dữ liệu trên danh sách mối quan hệ, chúng ta tạo 1 modulecấp cao hơn, đặt tên Research.public class Research{ public Research(Relationships relationships) { // accessing low-level interface for researching var relations = relationships.Relations; foreach (var r in relations.Where( x =&gt; x.Item1.Name == \"John\" &amp;&amp; x.Item2 == Relationship.Parent )) { WriteLine($\"John has a child called {r.Item3.Name}\"); } } static void Main(string[] args) { var parent = new Person { Name = \"John\" }; var child1 = new Person { Name = \"Chris\" }; var child2 = new Person { Name = \"Mary\" }; var relationships = new Relationships(); relationships.AddParentAndChild(parent, child1); relationships.AddParentAndChild(parent, child2); new Research(relationships); }}Lúc này, khi chạy chương trình, ta sẽ lấy được danh các con của đối tượng John.2. Vi phạm nguyên lýMặc dù chương trình chạy được, tuy nhiên, tại class Research (high-level), chúngta đang truy cập đến danh sách relations thông qua 1 low-level API từclass Relationships. Nếu như class Relationships quyết định thay đổi cấutrúc lưu trữ bên trong, việc thay đổi này sẽ ảnh hưởng đến Research.3. Cách giải quyếtThay vì để class Research phụ thuộc vào low-level API, chúng ta nên đểcả 2 phụ thuộc vào abstraction.Tiến hành tạo 1 interface đặt tên IRelationshipBrowser, interface nàyđịnh nghĩa các phương thức cần thiết để xử lý dữ liệu về relations.public interface IRelationshipBrowser{ IEnumerable&lt;Person&gt; FindAllChildrenOf(string name);}Tiếp đến, tiến hành thực thi interface này cho lớp Relationships// low-level partpublic class Relationships : IRelationshipBrowser{ private List&lt;(Person, Relationship, Person)&gt; relations = new List&lt;(Person, Relationship, Person)&gt;(); public void AddParentAndChild(Person parent, Person child) { relations.Add((parent, Relationship.Parent, child)); relations.Add((child, Relationship.Child, parent)); } public List&lt;(Person, Relationship, Person)&gt; Relations =&gt; relations; public IEnumerable&lt;Person&gt; FindAllChildrenOf(string name) { foreach (var r in relations.Where( x =&gt; x.Item1.Name == \"John\" &amp;&amp; x.Item2 == Relationship.Parent )) { yield return r.Item3; } }}Lúc này, tại high-level class Research, thay vì phụ thuộc trực tiếpvào class Relationships để lấy dữ liệu về relations, ta sửa lạiđể class Research phụ thuộc vào interface IRelationshipBrowser. ( Bởi vì trên interface này đã có các phương thức xử lý dữ liệu relations)public class Research{ public Research(IRelationshipBrowser browser) { foreach (var p in browser.FindAllChildrenOf(\"John\")) WriteLine($\"John has a child called {p.Name}\"); } static void Main(string[] args) { var parent = new Person { Name = \"John\" }; var child1 = new Person { Name = \"Chris\" }; var child2 = new Person { Name = \"Mary\" }; var relationships = new Relationships(); relationships.AddParentAndChild(parent, child1); relationships.AddParentAndChild(parent, child2); new Research(relationships); }}Lúc này, class Relationships có thể thoải mái thay đổi cấu trúc lưutrữ bên trong. Thay vì dùng tuple, có thể dùng dictionary,…Mặc dù cấu trúc thay đổi, tuy nhiên cả 2 class đều tuân theo interfaceIRelationshipBrowser, do đó chương trình vẫn sẽ hoạt động bình thường.Không có điều gì ảnh hưởng đến class Research cả.Tổng kết Single Responsibility Principle A class should noly have one reason to change Seperation of concerns - different class handling different, independenttasks/problems Open - Closed principle Classes should be open for extension but closed for modification Liskov substition principle You should be able to substitute a base type for a subtype Interface Segregation Principle Don’t put too much into an interface Split into seperate interfaces YAGNI - You Ain’t Going to Need It Dependency Inversion Principle High-level modules should not depend upon low-level ones Use abstractions Tham khảo Design Patterns in C# and .NET" }, { "title": "SOLID - Interface Segregation Principle", "url": "/posts/interface-segregation-principle/", "categories": "Design Pattern, SOLID", "tags": "solid, interface segregation principle, udemy, design patterns in c# and .net, decorator", "date": "2022-09-03 16:58:00 +0700", "snippet": "Đây là nguyên lý thứ 4 trong bộ 5 nguyên lí SOLID. Nguyên lý này chỉ ra rằng interface của1 chương trình nên được phân tách nhỏ sao cho những người lập trình chỉ cần thực thi nhữnginterface mà họ c...", "content": "Đây là nguyên lý thứ 4 trong bộ 5 nguyên lí SOLID. Nguyên lý này chỉ ra rằng interface của1 chương trình nên được phân tách nhỏ sao cho những người lập trình chỉ cần thực thi nhữnginterface mà họ cần. Tránh việc phải thực thi 1 interface quá lớn, bao gồm quá nhiềunhững phương thức thừa thãi.1. Đặt vấn đềGiả sử chúng ta làm việc với đối tượng Document, xoay quanh đối tượng này, chúng tacó các thao tác liên quan như in ấn, scan, chuyển fax,… Để nhanh chóng, chúng tađịnh nghĩa hết tất cả đối tượng này vào trong 1 interface duy nhất.Tiếp đến, ta có đối tượng MultiFunctionPrinter thực thi interface này và định nghĩatoàn bộ các phương thức tương ứng. Đến đây, chương trình hoạt động hoàn toàn bình thường.public class Document{}public interface IMachine{ void Print(Document d); void Scan(Document d); void Fax(Document d);}public class MultiFunctionPrinter : IMachine{ public void Print(Document d) { // } public void Scan(Document d) { // } public void Fax(Document d) { // }}2. Vi phạm nguyên líSau đó, chúng ta mở rộng hệ thống, hỗ trợ các thao tác quản lý tài liệu thông qua 1 máy incũ hơn, đặt tên OldFashionPrinter, chiếc máy này chỉ có duy nhất 1 chức năng Print, khôngthể Scan hay Fax.Lúc này, để đảm bảo hệ thống hoạt động được, ta phải thực thi interface IMachine cho lớpnày. Tuy nhiên, ta phải viết hướng dẫn rõ ràng bởi vì lớp này không thể Scan hay Fax.Điều này gây nhầm lẫn rất lớn, bởi vì class IMachine thực thi interface IMachine nhưngnó không thể thực hiện hết chức năng của interface này.Điều này đã vi phạm nguyên lí Interface Segregation, nguyên lí này đảm bảo rằng: People don’t pay for thing they don’t needTức là, chúng ta không cần phải thực hiện những tính năng mà chúng ta không cần đến.public class OldFashionPrinter : IMachine{ public void Print(Document d) { // } public void Scan(Document d) { throw new NotImplementedException(); } public void Fax(Document d) { throw new NotImplementedException(); }}3. Cách giải quyếtCách thức giải quyết khá đơn giản, thay vì khai báo 1 interface chịu trách nhiệm chorất nhiều công việc cùng lúc. Chúng ta nên chia nhỏ interface này, mỗi interfacenhỏ chịu trách nhiệm cho 1 công việc cụ thể. (Seperation of Concern)public interface IPrinter{ void Print(Document d);}public interface IScanner{ void Scan(Document d);}public interface IFaxer{ void Fax(Document d);}Lúc này, giả sử 1 đối tượng Photocopier có khả năng Print và Scan, chúng ta chỉ cầnthực hiện như dưới đây:public class Photocopier : IPrinter, IScanner{ void Print(Document d) { } void Scan(Document d) { }}Hoặc nếu muốn 1 interface mang tính trừu tượng hơn, ta hoàn toàn có thể kết hợp cácinterface nhỏ thành 1 interface lớn hơn thông qua tính kế thừa của interface.public interface IMultiFunctionDevice : IScanner, IPrinter, IFaxer{}Lúc này, ta có thể định nghĩa lớp MultiFunctionMachine thực thi interface IMultiFunctionDevicevà định nghĩa tất cả các phương thức:public class MultiFunctionMachine : IMultiFunctionDevice{ public void Print(Document d) {} public void Scan(Document d) {} public void Fax(Document d) {}}Hoặc, nếu đã có các lớp thực thi những interface con, ta có thể dùng luôn các lớp con này.Cách thức thực hiện dưới đây còn được biết đến với tên gọi decorator pattern.public class MultiFunctionMachineComposition : IMultiFunctionDevice{ private IPrinter printer; private IScanner scanner; private IFaxer faxer; public MultiFunctionMachineComposition(IPrinter printer, IScanner scanner, IFaxer faxer) { this.printer = printer; this.scanner = scanner; this.faxer = faxer; } public void Print(Document d) { printer.Print(d); } public void Scan(Document d) { scanner.Scan(d); } public void Fax(Document d) { faxer.Fax(d); }}Tham khảo Design Patterns in C# and .NET" }, { "title": "SOLID - Liskov Substitution Principle", "url": "/posts/liskov-substitution-principle/", "categories": "Design Pattern, SOLID", "tags": "solid, liskov substitution principle, udemy, design patterns in c# and .net", "date": "2022-09-03 16:01:00 +0700", "snippet": "Đây là nguyên lí thứ 3 trong bộ 5 nguyên lí SOLID. Theo như “Barbara Liskov” và “Jeannette Wing”,nguyên lí này chỉ ra rằng: Let Φ(x) be a property provable about objects x of type T. Then Φ(y) sho...", "content": "Đây là nguyên lí thứ 3 trong bộ 5 nguyên lí SOLID. Theo như “Barbara Liskov” và “Jeannette Wing”,nguyên lí này chỉ ra rằng: Let Φ(x) be a property provable about objects x of type T. Then Φ(y) should be true for objects y of type S where S is a subtype of T.Đơn giản hơn, nguyên lý này ngụ ý rằng, khi 1 đối tượng của 1 lớp được truyền hoặc mở rộng sang1 lớp khác. Lớp cha phải có khả năng thay thế lớp con.1. Đặt vấn đềĐể làm rõ nguyên lý này, chúng ta sẽ đến với ví dụ về bài toán hình học. Giả sửchúng ta có đối tượng hình chữ nhật như dưới đâypublic class Rectangle{ public int Width { get; set; } public int Height { get; set; } public Rectangle() { } public Rectangle(int width, int height) { Width = width; Height = height; } public override string ToString() { return $\"Width: {Width} - Height: {Height}\"; }}public class Demo{ static public int Area(Rectangle r) =&gt; r.Width * r.Height; static void Main([]string args) { Rectangle rc = new Rectangle(2, 3); WriteLine($\"{rc} has area {Area(rc)}\"); }}Sau khi đối tượng Rectangle đã hoạt động tốt, chúng ta quyết địnhthực hiện điều tương tự với đối tượng Square (hình vuông). Và kế thừalà cách nhanh nhất để làm điều này.Hình vuông có width và height giống nhau, do đó ta quyết định sẽghi đè phương thức setter cho 2 thuộc tính này.public class Square : Rectangle{ public new int Width { set { base.Width = base.Height = value; } } public new int Height { set { base.Height = base.Width = value; } }}Việc thay đổi này hoàn toàn hoạt động giống như cách chúng ta mong muốn.public class Demo{ static public int Area(Rectangle r) =&gt; r.Width * r.Height; static void Main([]string args) { Rectangle rc = new Rectangle(2, 3); WriteLine($\"{rc} has area {Area(rc)}\"); Square sq = new Square(); sq.Width = 4; WriteLine($\"{sq} has area {Area(sq)}\"); }}2. Vi phạm nguyên lýTa có thể thấy rõ rằng, Square kế thừa từ Rectangle, như vậy các đối tượngthuộc lớp Square đồng thời cũng thuộc lớp Rectangle.Vậy nếu trong ví dụ trên, ta thay đổi Square thành Rectangle thì liệurằng chương trình còn hoạt động như chúng ta mong muốn hay không?public class Demo{ static public int Area(Rectangle r) =&gt; r.Width * r.Height; static void Main([]string args) { Rectangle rc = new Rectangle(2, 3); WriteLine($\"{rc} has area {Area(rc)}\"); Rectangle sq = new Square(); sq.Width = 4; WriteLine($\"{sq} has area {Area(sq)}\"); }}Lúc này, diện tích của hình vuông bên dưới không còn là 16 nữa mà là 0. Lý dobởi vì lúc này sq đang thuộc kiểu Rectangle, khi đặt giá trị cho thuộc tínhWidth, chỉ có duy nhất Width thay đổi. Thuộc tính Height mặc định nanggiá trị 0.Điều này vi phạm nguyên lí Liskov Substitution, nguyên lí này chỉ ra rằng chúng ta luôncó thể chuyển đổi đối tượng từ lớp kế thừa về lớp gốc mà các thao tác chức năng vẫn hoạtđộng như thông thường.Áp dụng vào ví dụ trên, khi đối tượng thuộc lớp Square được ép về lớp Rectangle, thaotác tính diện tích vẫn phải hoạt động bình thường.3. Cách giải quyếtCách thức giải quyết của ví dụ bên trên khá đơn giản. Thay vì dùng từ khoá new để làmmới phương thức setter, ta có thể kết hợp virtual và override.public class Rectangle{ public virtual int Width { get; set; } public virtual int Height { get; set; } public Rectangle() { } public Rectangle(int width, int height) { Width = width; Height = height; } public override string ToString() { return $\"Width: {Width} - Height: {Height}\"; }}public class Square : Rectangle{ public override int Width { set { base.Width = base.Height = value; } } public override int Height { set { base.Height = base.Width = value; } }}Khi chúng ta đặt Width cho hình vuông sq (lúc này đang được ép kiểu về Rectangle),hệ thống sẽ nhận thấy thuộc Width trên Rectangle là virtual, do đó nó sẽ xemxét trên Square có override lại thuộc tính này hay không. Và do chúng ta đã overridenên hệ thống sẽ set giá trị dựa trên thuộc tính Width được khai báo ở Square ( đồng thời đặt giá trị cho Height)public class Demo{ static public int Area(Rectangle r) =&gt; r.Width * r.Height; static void Main([]string args) { Rectangle rc = new Rectangle(2, 3); WriteLine($\"{rc} has area {Area(rc)}\"); Rectangle sq = new Square(); sq.Width = 4; WriteLine($\"{sq} has area {Area(sq)}\"); }}Tham khảo Design Patterns in C# and .NET Wiki" }, { "title": "SOLID - Open Close Principle", "url": "/posts/solid-open-close-principle/", "categories": "Design Pattern, SOLID", "tags": "solid, open close principle, udemy, design patterns in c# and .net", "date": "2022-09-03 10:36:00 +0700", "snippet": "Đây là nguyên lí thứ 2 trong bộ 5 nguyên lý SOLID. Ý tưởng của nguyên lý này chỉ rằng:1 đối tượng của phần mềm nên được mở rộng để thêm mới nhưng đóng lại khi thay đổi. Tức là,những thứ như class, ...", "content": "Đây là nguyên lí thứ 2 trong bộ 5 nguyên lý SOLID. Ý tưởng của nguyên lý này chỉ rằng:1 đối tượng của phần mềm nên được mở rộng để thêm mới nhưng đóng lại khi thay đổi. Tức là,những thứ như class, function,… nên được tạo theo 1 cách thức mà những logic củanó có thể được mở rộng ra mà không cần phải thay đổi những đoạn mã nguồn ban đầu.1. Đặt vấn đềGiả sử chúng ta có 1 trang buôn bán sản phẩm. Các sản phẩm có các thuộc tính như Màu sắc Kích thướcNgười dùng có thể dùng tính năng filter để lọc danh sách sản phẩm, từ đó tìmra được các sản phẩm ưng ý để thêm vào giỏ hàng.Trước hết, chúng ta sẽ xây dựng cấu trúc Product như dưới đâypublic enum Color{ Red, Green, Blue}public enum Size{ Small, Medium, Large, Yuge}public class Product{ public string Name; public Color Color; public Size Size; public Product(string name, Color color, Size size) { Name = name; Color = color; Size = size; }}Để cung cấp tính năng lọc sản phẩm, ta tiến hành tạo class ProductFiltervà viết các phương thức lọc: FilterBySize FilterByColorpublic class ProductFilter{ public IEnumerable&lt;Product&gt; FilterBySize(IEnumerable&lt;Product&gt; products, Size size) { foreach (var p in products) if (p.Size == size) yield return p; } public IEnumerable&lt;Product&gt; FilterByColor(IEnumerable&lt;Product&gt; products, Color color) { foreach (var p in products) if (p.Color == color) yield return p; }}Khi thực thi chương trình dưới đây, chúng ta sẽ lấy được danh sách các sản phẩmcó màu xanh trong hệ thống.public class Demo{ static void Main(string[] args) { var apple = new Product(\"Apple\", Color.Green, Size.Small); var tree = new Product(\"Tree\", Color.Green, Size.Large); var house = new Product(\"House\", Color.Blue, Size.Large); Product[] products = {apple, tree, house}; var pf = new ProductFilter(); WriteLine(\"Green products (old):\"); foreach(v p in pf.FilterByColor(products, Color.Green)) { WriteLine($\" - {p.Name} is green\"); } }}2. Vi phạm nguyên lýLúc này chúng ta đã có hệ thống lọc sản phẩm theo 2 phương pháp: Lọc theo màu Lọc theo kích thước2 phương thức lọc này đều do class ProductFilter cung cấp. Tuy nhiên, giả sử lúc này khác hàngyêu cầu hệ thống phải cung cấp chức năng lọc theo cả màu sắc lẫn kích thước. Chúng ta sẽ phải quay lạiclass ProductFilter để chỉnh sửa, thêm vào 1 phương thức mới. Và cứ tiếp diễn như vậy mỗi lầnkhách hàng yêu cầu chức năng lọc mới.public class ProductFilter{ public IEnumerable&lt;Product&gt; FilterBySizeAndColor(IEnumerable&lt;Product&gt; products, Size size, Color color) { foreach (var p in products) if (p.Size == size &amp;&amp; p.Color == color) yield return p; }}Và điều này đã vi phạm nguyên lý Open Close, ý tưởng của nguyên lý này chỉ rằng 1 class nên cung cấpkhả năng để mở rộng, nhưng không nên chỉnh sửa từ trong chính bản thân class.Khi áp dụng vào class ProductFilter, ta có thể diễn giải như sau. class ProductFilter nêncung cấp khả năng để thêm vào các bộ lọc mới. Đồng thời, không nên chỉnh sửa trực tiếp bên trong classnày, tức là không một ai quay lại class ProductFilter để chỉnh sửa class này và thêm vào cácphương thức lọc mới (như cách chúng ta làm với phương thức FilterBySizeAndColor). Lý do đưa ra của việclàm này đó là sản phẩm đã được cung cấp cho khách hàng, chúng ta không thể truy cập vào để sửa chữatrực tiếp được.3. Cách giải quyếtCách giải quyết đơn giản nhất cho vấn đề này đó là áp dụng tính chất kế thừa. Bên cạnh đó, chúngta có thể sử dụng interface và 1 Enterprise Pattern tên là Specification Pattern. Sử dụng patternnày có thể giúp chúng ta tránh được việc vi phạm nguyên lý Open Close.Để thực hiện pattern này, ta tiến hành định nghĩa 1 số interfacepublic interface ISpecification&lt;T&gt;{ bool IsSatisfied(T t);}public interface IFilter&lt;T&gt;{ IEnumerable&lt;T&gt; Filter(IEnumerable&lt;T&gt; items, ISpecification&lt;T&gt; spec);}Lúc này, để cung cấp tính năng lọc, ta định nghĩa từng Specification tương ứngpublic class ColorSpecification : ISpecification&lt;Product&gt;{ private Color color; public ColorSpecification(Color color) { this.color = color; } public bool IsSatisfied(Product t) { return t.color == color; }}public class SizeSpecification : ISpecification&lt;Product&gt;{ private Size Size; public SizeSpecification(Size Size) { this.Size = Size; } public bool IsSatisfied(Product t) { return t.Size == Size; }}Tiếp đó, định nghĩa class BetterFilter thực thi IFilter đảm nhận chức năng lọc.public class BetterFilter : IFilter&lt;Product&gt;{ public IEnumerable&lt;Product&gt; Filter(IEnumerable&lt;Product&gt; products, ISpecification&lt;Product&gt; spec) { foreach (var p in products) if (spec.IsSatisfied(p)) yield return p; }}Khi đó, ta có thể dùng chương trình dưới đây để lọc ra các sản phẩm có màu xanhpublic class Demo{ static void Main(string[] args) { var apple = new Product(\"Apple\", Color.Green, Size.Small); var tree = new Product(\"Tree\", Color.Green, Size.Large); var house = new Product(\"House\", Color.Blue, Size.Large); Product[] products = {apple, tree, house}; var pf = new ProductFilter(); WriteLine(\"Green products (old):\"); foreach(var p in pf.FilterByColor(products, Color.Green)) { WriteLine($\" - {p.Name} is green\"); } var bf = new BetterFilter(); var colorSpec = new ColorSpecification(Color.Green); WriteLine(\"Green products (new):\"); foreach(var p in bf.Filter(products, colorSpec)) { WriteLine($\" - {p.Name} is green\"); } }}Khi cần lọc sản phẩm theo nhiều điều kiện (cả màu sắc và kích thước), ta có thể mở rộngfilter thông qua combinator, cách thức thực hiện như dưới đâypublic class AndSpecification&lt;T&gt; : ISpecification&lt;T&gt;{ private ISpecification&lt;T&gt; first, second; public AndSpecification(ISpecification&lt;T&gt; first, ISpecification&lt;T&gt; second) { this.first = first; this.second = second; } public bool IsSatisfied(T t) { return first.IsSatisfied(t) &amp;&amp; second.IsSatisfied(t); }}public class Demo{ static void Main(string[] args) { var apple = new Product(\"Apple\", Color.Green, Size.Small); var tree = new Product(\"Tree\", Color.Green, Size.Large); var house = new Product(\"House\", Color.Blue, Size.Large); Product[] products = {apple, tree, house}; var pf = new ProductFilter(); WriteLine(\"Green products (old):\"); foreach(var p in pf.FilterByColor(products, Color.Green)) { WriteLine($\" - {p.Name} is green\"); } var bf = new BetterFilter(); var colorSpec = new ColorSpecification(Color.Green); WriteLine(\"Green products (new):\"); foreach(var p in bf.Filter(products, colorSpec)) { WriteLine($\" - {p.Name} is green\"); } WriteLine(\"Large blue items:\"); var sizeLargeSpec = new SizeSpecification(Size.Large); var colorBlueSpec = new ColorSpecification(Color.Blue); var andSpec = new AndSpecification&lt;Product&gt;(sizeLargeSpec, colorBlueSpec); foreach (var p in bf.Filter(products, andSpec)) { WriteLine($\" - {p.Name} is large and blue\"); } }}Thông qua ví dụ trên, chúng ta có thể thấy rõ việc thêm vào các bộ lọc mới cực kì dễ dàngthông qua việc tạo thêm các Specification. Đồng thời, class BetterFilter đảm nhậnchức năng lọc sản phẩm chỉ cần viết 1 lần và hiếm khi cần phải thay đổi.Tham khảo Design Patterns in C# and .NET" }, { "title": "SOLID - Single Responsibility Principle", "url": "/posts/solid-single-responsibility-principle/", "categories": "Design Pattern, SOLID", "tags": "solid, single responsibility, udemy, design patterns in c# and .net", "date": "2022-09-03 09:50:00 +0700", "snippet": "Single Responsibility hay còn gọi là nguyên lý đơn trách nhiệm. Đây là lời khuyênđầu tiên trong bộ 5 nguyên lý SOLID. Ý tưởng đằng sau nguyên lý này đó là: mỗiclass, module hoặc function trong 1 ch...", "content": "Single Responsibility hay còn gọi là nguyên lý đơn trách nhiệm. Đây là lời khuyênđầu tiên trong bộ 5 nguyên lý SOLID. Ý tưởng đằng sau nguyên lý này đó là: mỗiclass, module hoặc function trong 1 chương trình chỉ nên chịu trách nhiệmcho 1 thứ duy nhất và chỉ có duy nhất 1 lý do để thay đổi. Chúng ta hãy cùngtìm hiểu nguyên lý này thông qua minh hoạ dưới đây.1. Đặt vấn đềGiả sử ban đầu chúng ta tạo 1 class để lưu trữ nhật ký, đặt tên Journalpublic class Journal{ private readonly List&lt;string&gt; entries = new List&lt;string&gt;(); private static int count = 0; public int AddEntry(string text) { entries.Add($\"{++count}: {text}\"); return count; // memento pattern } public void RemoveEntry(int index) { entries.RemoveAt(index); } public override string ToString() { return string.Join(Environment.NewLine, entries); }}public class Demo{ static void Main(string[] args) { var j = new Journal(); j.AddEntry(\"First Entry\"); j.AddEntry(\"Second Entry\"); WriteLine(j); }}Hiện tại, 2 phương thức trong class Journal đều liên quan tới đối tượngnhật ký, bao gồm: AddEntry: thêm nhật ký mới RemoveEntry: xoá bỏ nhật ký theo vị trí2. Vi phạm nguyên lýBây giờ, hãy hình dung chúng ta muốn lưu trữ những dòng nhật ký này. Có thể lưutrữ vào tập tin hoặc cơ sở dữ liệu,… Chúng ta có thể nhanh chóng tạo phươngthức Save và Load trực tiếp vào class Journal như dưới đâyclass Journal{ public void Save(string filename) { File.WriteAllText(filename, ToString()); } public static Journal Load(string filename) { } public static Journal Load(Uri uri) { }}Tuy nhiên, khi thực hiện như trên, chúng ta đã vi phạm nguyên lý Single Responsibility. Lúc này class Journal phải đảm nhiệm 2 trách nhiệm: Thực hiện các thao tác liên quan đến nhật ký Lưu trữ và load dữ liệuDo đó, class Journal cũng có 2 lý do để thay đổi. Từ đó, vi phạm nguyênlý Signle Responsibility.3. Cách giải quyếtĐể giải quyết vấn đề vi phạm nguyên lý, chúng ta có thể refactor những phươngthức liên quan đến việc lưu trữ vào 1 class riêng, đặt tên Persistence.class Persistence{ public void SaveToFile(Journal j, string filename, bool overwrite = false) { if (override || !File.Exists(filename)) File.WriteAllText(filename, j.ToString()); }}Thông qua việc phân tách class chúng ta cũng áp dụng nguyên lý Seperation of Concern. Tức là, mỗi class chỉ nên quan tâm đến 1 thứ. Journal: quan tâm đến việc thực hiện các thao tác trên nhật ký Persistence: quan tâm đến việc lưu trữ dữ liệuChương trình cuối cùng sẽ như dưới đây:public class Demo{ static void Main(string[] args) { var j = new Journal(); j.AddEntry(\"First Entry\"); j.AddEntry(\"Second Entry\"); var p = new Persistence(); var filename = \"data.txt\"; p.SaveToFile(j, filename, true); }}Tham khảo Design Patterns in C# and .NET" }, { "title": "Làm quen với Design Pattern", "url": "/posts/design-pattern-getting-started/", "categories": "Design Pattern, Overview", "tags": "design pattern, design pattern overview", "date": "2022-09-03 09:31:00 +0700", "snippet": "Trong quá trình phát triển phần mềm, 1 mẫu thiết kế (design pattern) là1 giải pháp cho 1 vấn đề phổ biến có tính lặp đi lặp lại. 1 mẫu thiết kếkhông phải là 1 thiết kế hoàn chỉnh từ a tới á để có t...", "content": "Trong quá trình phát triển phần mềm, 1 mẫu thiết kế (design pattern) là1 giải pháp cho 1 vấn đề phổ biến có tính lặp đi lặp lại. 1 mẫu thiết kếkhông phải là 1 thiết kế hoàn chỉnh từ a tới á để có thể biến đổi trực tiếpsang code. Nó chỉ đơn thuần là 1 bản mô tả các bước để giải quyết vấn đề vàcó thể được ứng dụng trong rất nhiều tình huống thực tế.1. Design pattern được áp dụng như thế nào?Các design pattern có thể đẩy nhanh quá trình phát triển thông qua việc cungcấp các mô hình đã được kiểm thử, chứng minh. Việc sử dụng các design patterngiúp tránh những vấn đề gây ra lỗi nghiêm trọng. Đồng thời, giúp mã nguồnsáng sủa dễ đọc hơn.2. Creational Design Pattern Abstract Factory Builder Factory Method Object Pool Prototype Singleton3. Structural Design Pattern Adapter Bridge Composite Decorator Facade Flyweight Private Class Data Proxy4. Behavioral Design Pattern Chain of respository Command Interpreter Iterator Mediator Memento Null Object Observer State Strategy Template Method VisitorTham khảo https://sourcemaking.com/design_patterns" }, { "title": "Bắt đầu với nền tảng GVA", "url": "/posts/gva-quick-start/", "categories": "Lib/Framework, GVA", "tags": "golang, gin, gva, open source", "date": "2022-09-03 09:05:00 +0700", "snippet": "", "content": "" }, { "title": "Xin chào DalatCoder", "url": "/posts/hello-dalatcoder/", "categories": "Demo, DalatCoder", "tags": "demo, dalatcoder, hello world", "date": "2022-09-01 20:26:00 +0700", "snippet": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi rhoncus neque interdum turpis fringilla, sed elementum sapien maximus. Nullam scelerisque justo nec ex congue facilisis. Integer scele...", "content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi rhoncus neque interdum turpis fringilla, sed elementum sapien maximus. Nullam scelerisque justo nec ex congue facilisis. Integer scelerisque odio id dolor posuere, eu viverra urna aliquet. Vestibulum pellentesque, purus ac aliquam vehicula, mauris erat maximus sem, in condimentum libero dui eget lorem. Ut vestibulum egestas quam, ac vulputate purus tristique ut. Nunc tortor neque, maximus id consectetur id, faucibus ut enim. Fusce sit amet molestie urna. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nulla eu ultrices orci. Pellentesque congue magna ut magna lobortis, vitae laoreet nisl egestas.Section 1Đoạn văn đầu tiên Hello WorldLorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi rhoncus neque interdum turpis fringilla, sed elementum sapien maximus. Nullam scelerisque justo nec ex congue facilisis. Integer scelerisque odio id dolor posuere, eu viverra urna aliquet. Vestibulum pellentesque, purus ac aliquam vehicula, mauris erat maximus sem, in condimentum libero dui eget lorem. Ut vestibulum egestas quam, ac vulputate purus tristique ut. Nunc tortor neque, maximus id consectetur id, faucibus ut enim. Fusce sit amet molestie urna. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nulla eu ultrices orci. Pellentesque congue magna ut magna lobortis, vitae laoreet nisl egestas.Section 2Tìm các dự án của DalatCoder tại github/dalatcoderNullam sem diam, tincidunt nec posuere in, aliquet quis sem. Curabitur vehicula nunc pellentesque lectus blandit convallis. Nulla facilisi. Praesent ac rutrum ex, non facilisis nisl. Donec pretium hendrerit dapibus. Suspendisse nunc velit, blandit eu magna sit amet, auctor posuere lacus. Sed eget purus non lacus tincidunt vulputate placerat vel dolor. Donec et quam quis lacus tristique dignissim non sed velit. Ut at neque et justo malesuada semper eu vel elit. Maecenas mattis, nisl sed ullamcorper interdum, turpis nulla bibendum sem, at venenatis tortor elit dignissim lectus. Aenean gravida vitae orci vitae suscipit. Nulla at placerat neque. Fusce sit amet lobortis erat. Sed at mattis diam.Section 3Minh hoạ ảnhDalatCoder AvatarDonec dictum libero nec sem interdum, sed accumsan ex finibus. Maecenas vestibulum eleifend libero, id suscipit ligula. Suspendisse vel accumsan quam. Suspendisse ac mi porttitor, sagittis quam at, porttitor dui. Cras nec dapibus ex. Proin ex sapien, vestibulum a cursus id, molestie non risus. Vivamus at libero dui. Phasellus ut lectus neque. Nunc iaculis, tortor egestas finibus scelerisque, libero elit posuere tellus, hendrerit suscipit ligula dolor sed sapien. Integer eu volutpat risus. Duis imperdiet nulla neque, suscipit convallis lacus varius et.console.log('Hello World')" } ]
